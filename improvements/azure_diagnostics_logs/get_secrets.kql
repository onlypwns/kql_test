// ============================================================================
// QUERY: Azure Key Vault Secret Access Monitoring
// ============================================================================
//
// PURPOSE:
//   Monitors successful secret retrievals from Azure Key Vault to detect
//   unauthorized access, potential credential theft, or suspicious access
//   patterns that could indicate compromised identities or applications.
//
// MITRE ATT&CK:
//   - T1555: Credentials from Password Stores
//   - T1552.001: Unsecured Credentials - Credentials In Files
//   - T1078.004: Valid Accounts - Cloud Accounts
//   - T1552.004: Unsecured Credentials - Private Keys
//
// THREAT CONTEXT:
//   Azure Key Vault stores sensitive secrets, certificates, and keys used
//   by applications and services. Monitoring secret access helps detect
//   compromised identities attempting to retrieve credentials for lateral
//   movement, privilege escalation, or data access.
//
// DATA SOURCE:
//   - AzureDiagnostics (Key Vault audit logs)
//   - Requires: Azure Key Vault with diagnostic settings enabled
//
// DETECTION METHOD:
//   Tracks successful SecretGet operations, excluding system/service accounts,
//   to identify potentially unauthorized secret access.
//
// RECOMMENDATIONS:
//   - Alert on secret access from unusual identities or IPs
//   - Monitor for bulk secret retrieval (multiple secrets in short time)
//   - Investigate access to high-value secrets (production credentials)
//   - Review access patterns after identity compromise alerts
//   - Implement Key Vault access policies with least privilege
//
// PERFORMANCE NOTES:
//   - Estimated execution time: < 10 seconds for 30 days of data
//   - Efficient with specific operation and result filters
//   - Suitable for near-real-time alerting
//
// KNOWN FALSE POSITIVES:
//   - Legitimate application secret retrieval during deployment
//   - DevOps pipelines accessing secrets
//   - Monitoring/scanning tools
//   - Rate: Medium (10-20% without filtering service accounts)
//
// LAST UPDATED: 2026-01-19
// VERSION: 2.0
// ============================================================================

// Configuration Parameters
let lookbackPeriod = 30d;  // Time window for analysis
let minAccessCount = 3;     // Minimum accesses to flag for investigation
let excludeSystemAccounts = true;  // Filter out known system accounts

// Main Detection Logic
AzureDiagnostics
| where TimeGenerated >= ago(lookbackPeriod)
// Filter to Key Vault operations
| where ResourceProvider == "MICROSOFT.KEYVAULT"
// Focus on secret retrieval operations
| where OperationName == "SecretGet"
// Only successful retrievals (compromised accounts will succeed)
| where ResultType == "Success"
// Exclude system principal core operations (reduce noise)
| where Resource != "PRINCIPALKEYCORE"
// ============================================================================
// EXTRACT AND ENRICH IDENTITY INFORMATION
// ============================================================================
| extend
    // Extract caller identity (UPN or service principal)
    CallerIdentity = coalesce(identity_claim_upn_s, identity_claim_appid_s, CallerIPAddress),
    // Extract secret name from request
    SecretName = extract(@"secrets/([^/]+)", 1, id_s),
    // Determine identity type
    IdentityType = case(
        isnotempty(identity_claim_upn_s), "User",
        isnotempty(identity_claim_appid_s), "ServicePrincipal",
        "Unknown"
    ),
    // Extract additional client context
    ClientInfo = clientInfo_s
// Optional: Filter out known system/service accounts
| where excludeSystemAccounts == false
    or (IdentityType != "ServicePrincipal" and CallerIdentity !contains "system")
// ============================================================================
// AGGREGATE AND ANALYZE ACCESS PATTERNS
// ============================================================================
| summarize
    AccessCount = count(),
    FirstAccess = min(TimeGenerated),
    LastAccess = max(TimeGenerated),
    SecretsAccessed = make_set(SecretName),
    UniqueSecrets = dcount(SecretName),
    SourceIPs = make_set(CallerIPAddress),
    ClientInfos = make_set(ClientInfo)
by CallerIdentity, IdentityType, Resource, ResourceGroup
// Filter to accounts with significant access
| where AccessCount >= minAccessCount
// Calculate access metrics
| extend
    AccessDurationHours = round(datetime_diff('hour', LastAccess, FirstAccess), 1),
    AccessRate = round(toreal(AccessCount) / toreal(datetime_diff('hour', LastAccess, FirstAccess) + 1), 2),
    // Risk scoring based on access patterns
    RiskScore = case(
        UniqueSecrets >= 10 and AccessCount >= 20, "Critical",  // Bulk secret enumeration
        UniqueSecrets >= 5 and AccessCount >= 10, "High",       // Multiple secret access
        AccessCount >= 20, "High",                               // High-frequency access
        AccessCount >= 10, "Medium",
        "Low"
    ),
    AccessPattern = case(
        UniqueSecrets >= 10, "Bulk Enumeration",
        UniqueSecrets >= 5, "Multiple Secrets",
        AccessCount >= 20, "High Frequency",
        "Standard Access"
    )
// Enrich with risk indicators
| extend
    RiskIndicator = strcat("Key Vault Secret Access: ", AccessPattern),
    SuspicionLevel = case(
        RiskScore in ("Critical", "High"), "High Confidence",
        "Medium Confidence"
    )
// ============================================================================
// OUTPUT WITH PRIORITIZATION
// ============================================================================
| project
    FirstAccess,
    LastAccess,
    CallerIdentity,
    IdentityType,
    KeyVaultName = Resource,
    ResourceGroup,
    AccessCount,
    UniqueSecrets,
    AccessPattern,
    AccessDurationHours,
    AccessRate,
    RiskScore,
    RiskIndicator,
    SuspicionLevel,
    SecretsAccessed,
    SourceIPs,
    ClientInfos
| sort by RiskScore desc, AccessCount desc

// ============================================================================
// TROUBLESHOOTING
// ============================================================================
// - If no results: No suspicious Key Vault secret access detected
// - If too many results: Increase minAccessCount or enable excludeSystemAccounts
// - If missing expected activity: Check diagnostic settings and time range
//
// ENABLE KEY VAULT DIAGNOSTIC SETTINGS:
// Azure Portal > Key Vault > Monitoring > Diagnostic settings
// Enable logs:
// - AuditEvent (required for this query)
// - AllMetrics (optional, for performance monitoring)
//
// EXAMPLE INVESTIGATION WORKFLOWS:
// 1. Compromised identity investigation:
//    - Check if CallerIdentity appears in risky users or sign-in logs
//    - Review what secrets were accessed (SecretsAccessed)
//    - Determine potential impact of compromised secrets
// 2. Insider threat detection:
//    - Filter for IdentityType = "User" with high access counts
//    - Review normal access patterns for baseline
//    - Check for access outside business hours
// 3. Service principal compromise:
//    - Filter for IdentityType = "ServicePrincipal" with unusual patterns
//    - Verify if access aligns with application functionality
//    - Check for credential rotation history
//
// FOLLOW-UP QUERIES:
// - Get detailed access log for specific identity:
//   AzureDiagnostics
//   | where ResourceProvider == "MICROSOFT.KEYVAULT"
//   | where OperationName == "SecretGet"
//   | where identity_claim_upn_s == "<identity>" or identity_claim_appid_s == "<app_id>"
//   | project TimeGenerated, Resource, id_s, CallerIPAddress, clientInfo_s
//   | sort by TimeGenerated desc
//
// - Check all Key Vault operations from suspicious identity:
//   AzureDiagnostics
//   | where ResourceProvider == "MICROSOFT.KEYVAULT"
//   | where identity_claim_upn_s == "<identity>"
//   | summarize Operations = make_set(OperationName), Count = count()
//              by bin(TimeGenerated, 1h)
//   | sort by TimeGenerated desc
//
// - Identify secrets accessed by multiple suspicious identities:
//   AzureDiagnostics
//   | where ResourceProvider == "MICROSOFT.KEYVAULT"
//   | where OperationName == "SecretGet"
//   | extend SecretName = extract(@"secrets/([^/]+)", 1, id_s)
//   | summarize Identities = make_set(identity_claim_upn_s),
//               AccessCount = count() by SecretName
//   | where AccessCount > 10
//   | sort by AccessCount desc
//
// - Check for access from unusual locations/IPs:
//   AzureDiagnostics
//   | where ResourceProvider == "MICROSOFT.KEYVAULT"
//   | where OperationName == "SecretGet"
//   | summarize AccessCount = count(), Identities = make_set(identity_claim_upn_s)
//              by CallerIPAddress
//   | sort by AccessCount desc
//
// - Monitor secret access trends:
//   AzureDiagnostics
//   | where ResourceProvider == "MICROSOFT.KEYVAULT"
//   | where OperationName == "SecretGet"
//   | summarize AccessCount = count() by bin(TimeGenerated, 1d)
//   | render timechart
//
// RESPONSE ACTIONS:
// 1. **CRITICAL** (RiskScore = "Critical"):
//    - Immediately rotate all accessed secrets
//    - Revoke access for suspicious identity
//    - Review all resources using the compromised secrets
//    - Check for lateral movement or privilege escalation
// 2. **HIGH** (Bulk secret enumeration):
//    - Investigate identity for compromise
//    - Review authentication logs for suspicious sign-ins
//    - Check for data exfiltration attempts
//    - Rotate high-value secrets as precaution
// 3. **INVESTIGATION**:
//    - Document accessed secrets and their purposes
//    - Determine if access was authorized
//    - Review timeline against authentication events
//    - Check for correlated security alerts
// 4. **PREVENTION**:
//    - Implement least-privilege Key Vault access policies
//    - Use managed identities instead of secrets where possible
//    - Enable Key Vault soft delete and purge protection
//    - Configure Azure Policy to enforce access controls
//    - Implement just-in-time access for sensitive secrets
//    - Enable Azure Sentinel integration for advanced detection
//
// HIGH-VALUE SECRETS TO MONITOR:
// - Production database credentials
// - API keys and access tokens
// - Storage account keys
// - Certificate private keys
// - Service principal credentials
// - SSH keys and connection strings
// - Third-party service credentials
//
// KEY VAULT SECURITY BEST PRACTICES:
// - Use Azure RBAC for fine-grained access control
// - Enable Private Link for network isolation
// - Implement key rotation policies
// - Use managed identities for Azure resources
// - Enable soft delete and purge protection
// - Configure firewall rules and virtual network rules
// - Separate Key Vaults by environment (dev/test/prod)
// - Implement secret versioning
// - Use Azure Policy for compliance enforcement
// - Enable Azure Defender for Key Vault
